(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["autoComplete.min"],{

/***/ "./node_modules/@tarekraafat/autocomplete.js/dist/autoComplete.min.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tarekraafat/autocomplete.js/dist/autoComplete.min.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var e, t;
e = this, t = function() {
    "use strict";

    function e(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }))), n.push.apply(n, r)
        }
        return n
    }

    function t(t) {
        for (var n = 1; n < arguments.length; n++) {
            var i = null != arguments[n] ? arguments[n] : {};
            n % 2 ? e(Object(i), !0).forEach((function(e) {
                r(t, e, i[e])
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : e(Object(i)).forEach((function(e) {
                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
            }))
        }
        return t
    }

    function n(e) {
        return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }, n(e)
    }

    function r(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e
    }

    function i(e) {
        return function(e) {
            if (Array.isArray(e)) return s(e)
        }(e) || function(e) {
            if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
        }(e) || o(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function o(e, t) {
        if (e) {
            if ("string" == typeof e) return s(e, t);
            var n = Object.prototype.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? s(e, t) : void 0
        }
    }

    function s(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
        return r
    }

    var u = function(e) {
        return "string" == typeof e ? document.querySelector(e) : e()
    }, a = function(e, t) {
        var n = "string" == typeof e ? document.createElement(e) : e;
        for (var r in t) {
            var i = t[r];
            if ("inside" === r) i.append(n); else if ("dest" === r) u(i[0]).insertAdjacentElement(i[1], n); else if ("around" === r) {
                var o = i;
                o.parentNode.insertBefore(n, o), n.append(o), null != o.getAttribute("autofocus") && o.focus()
            } else r in n ? n[r] = i : n.setAttribute(r, i)
        }
        return n
    }, c = function(e, t) {
        return e = String(e).toLowerCase(), t ? e.normalize("NFD").replace(/[\u0300-\u036f]/g, "").normalize("NFC") : e
    }, l = function(e, n) {
        return a("mark", t({innerHTML: e}, "string" == typeof n && {class: n})).outerHTML
    }, f = function(e, t) {
        t.input.dispatchEvent(new CustomEvent(e, {bubbles: !0, detail: t.feedback, cancelable: !0}))
    }, p = function(e, t, n) {
        var r = n || {}, i = r.mode, o = r.diacritics, s = r.highlight, u = c(t, o);
        if (t = String(t), e = c(e, o), "loose" === i) {
            var a = (e = e.replace(/ /g, "")).length, f = 0, p = Array.from(t).map((function(t, n) {
                return f < a && u[n] === e[f] && (t = s ? l(t, s) : t, f++), t
            })).join("");
            if (f === a) return p
        } else {
            var d = u.indexOf(e);
            if (~d) return e = t.substring(d, d + e.length), d = s ? t.replace(e, l(e, s)) : t
        }
    }, d = function(e, t) {
        return new Promise((function(n, r) {
            var i;
            return (i = e.data).cache && i.store ? n() : new Promise((function(e, n) {
                return "function" == typeof i.src ? i.src(t).then(e, n) : e(i.src)
            })).then((function(t) {
                try {
                    return e.feedback = i.store = t, f("response", e), n()
                } catch (e) {
                    return r(e)
                }
            }), r)
        }))
    }, h = function(e, t) {
        var n = t.data, r = t.searchEngine, i = [];
        n.store.forEach((function(s, u) {
            var a = function(n) {
                var o = n ? s[n] : s, u = "function" == typeof r ? r(e, o) : p(e, o, {
                    mode: r,
                    diacritics: t.diacritics,
                    highlight: t.resultItem.highlight
                });
                if (u) {
                    var a = {match: u, value: s};
                    n && (a.key = n), i.push(a)
                }
            };
            if (n.keys) {
                var c, l = function(e, t) {
                    var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                    if (!n) {
                        if (Array.isArray(e) || (n = o(e)) || t && e && "number" == typeof e.length) {
                            n && (e = n);
                            var r = 0, i = function() {
                            };
                            return {
                                s: i, n: function() {
                                    return r >= e.length ? {done: !0} : {done: !1, value: e[r++]}
                                }, e: function(e) {
                                    throw e
                                }, f: i
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var s, u = !0, a = !1;
                    return {
                        s: function() {
                            n = n.call(e)
                        }, n: function() {
                            var e = n.next();
                            return u = e.done, e
                        }, e: function(e) {
                            a = !0, s = e
                        }, f: function() {
                            try {
                                u || null == n.return || n.return()
                            } finally {
                                if (a) throw s
                            }
                        }
                    }
                }(n.keys);
                try {
                    for (l.s(); !(c = l.n()).done;) a(c.value)
                } catch (e) {
                    l.e(e)
                } finally {
                    l.f()
                }
            } else a()
        })), n.filter && (i = n.filter(i));
        var s = i.slice(0, t.resultsList.maxResults);
        t.feedback = {query: e, matches: i, results: s}, f("results", t)
    }, m = "aria-expanded", b = "aria-activedescendant", y = "aria-selected", v = function(e, n) {
        e.feedback.selection = t({index: n}, e.feedback.results[n])
    }, g = function(e) {
        console.log(e);
        e.isOpen || ((e.wrapper || e.input).setAttribute(m, !0), e.list.removeAttribute("hidden"), e.isOpen = !0, f("open", e))
    }, w = function(e) {
        e.isOpen && ((e.wrapper || e.input).setAttribute(m, !1), e.input.setAttribute(b, ""), e.list.setAttribute("hidden", ""), e.isOpen = !1, f("close", e))
    }, O = function(e, t) {
        var n = t.resultItem, r = t.list.getElementsByTagName(n.tag), o = !!n.selected && n.selected.split(" ");
        if (t.isOpen && r.length) {
            var s, u, a = t.cursor;
            e >= r.length && (e = 0), e < 0 && (e = r.length - 1), t.cursor = e, a > -1 && (r[a].removeAttribute(y), o && (u = r[a].classList).remove.apply(u, i(o))), r[e].setAttribute(y, !0), o && (s = r[e].classList).add.apply(s, i(o)), t.input.setAttribute(b, r[t.cursor].id), t.list.scrollTop = r[e].offsetTop - t.list.clientHeight + r[e].clientHeight + 5, t.feedback.cursor = t.cursor, v(t, e), f("navigate", t)
        }
    }, A = function(e) {
        O(e.cursor + 1, e)
    }, k = function(e) {
        O(e.cursor - 1, e)
    }, L = function(e, t, n) {
        (n = n >= 0 ? n : e.cursor) < 0 || (e.feedback.event = t, v(e, n), f("selection", e), w(e))
    };

    function j(e, n) {
        var r = this;
        return new Promise((function(i, o) {
            var s, u;
            return s = n || ((u = e.input) instanceof HTMLInputElement || u instanceof HTMLTextAreaElement ? u.value : u.innerHTML), function(e, t, n) {
                return t ? t(e) : e.length >= n
            }(s = e.query ? e.query(s) : s, e.trigger, e.threshold) ? d(e, s).then((function(n) {
                try {
                    return e.feedback instanceof Error ? i() : (h(s, e), e.resultsList && function(e) {
                        var n = e.resultsList, r = e.list, i = e.resultItem, o = e.feedback, s = o.matches,
                            u = o.results;
                        if (e.cursor = -1, r.innerHTML = "", s.length || n.noResults) {
                            var c = new DocumentFragment;
                            u.forEach((function(e, n) {
                                var r = a(i.tag, t({
                                    id: "".concat(i.id, "_").concat(n),
                                    role: "option",
                                    innerHTML: e.match,
                                    inside: c
                                }, i.class && {class: i.class}));
                                i.element && i.element(r, e)
                            })), r.append(c), n.element && n.element(r, o), g(e)
                        } else w(e)
                    }(e), c.call(r))
                } catch (e) {
                    return o(e)
                }
            }), o) : (w(e), c.call(r));

            function c() {
                return i()
            }
        }))
    }

    var S = function(e, t) {
        for (var n in e) for (var r in e[n]) t(n, r)
    }, T = function(e) {
        var n, r, i, o = e.events, s = (n = function() {
            return j(e)
        }, r = e.debounce, function() {
            clearTimeout(i), i = setTimeout((function() {
                return n()
            }), r)
        }), u = e.events = t({input: t({}, o && o.input)}, e.resultsList && {list: o ? t({}, o.list) : {}}), a = {
            input: {
                input: function() {
                    s()
                }, keydown: function(t) {
                    !function(e, t) {
                        switch (e.keyCode) {
                            case 40:
                            case 38:
                                e.preventDefault(), 40 === e.keyCode ? A(t) : k(t);
                                break;
                            case 13:
                                t.submit || e.preventDefault(), t.cursor >= 0 && L(t, e);
                                break;
                            case 9:
                                t.resultsList.tabSelect && t.cursor >= 0 && L(t, e);
                                break;
                            case 27:
                                t.input.value = "", w(t)
                        }
                    }(t, e)
                }, blur: function() {
                    w(e)
                }
            }, list: {
                mousedown: function(e) {
                    e.preventDefault()
                }, click: function(t) {
                    !function(e, t) {
                        var n = t.resultItem.tag.toUpperCase(), r = Array.from(t.list.querySelectorAll(n)),
                            i = e.target.closest(n);
                        i && i.nodeName === n && L(t, e, r.indexOf(i))
                    }(t, e)
                }
            }
        };
        S(a, (function(t, n) {
            (e.resultsList || "input" === n) && (u[t][n] || (u[t][n] = a[t][n]))
        })), S(u, (function(t, n) {
            e[t].addEventListener(n, u[t][n])
        }))
    };

    function E(e) {
        var n = this;
        return new Promise((function(r, i) {
            var o, s, u;
            if (o = e.placeHolder, u = {
                role: "combobox",
                "aria-owns": (s = e.resultsList).id,
                "aria-haspopup": !0,
                "aria-expanded": !1
            }, a(e.input, t(t({
                "aria-controls": s.id,
                "aria-autocomplete": "both"
            }, o && {placeholder: o}), !e.wrapper && t({}, u))), e.wrapper && (e.wrapper = a("div", t({
                around: e.input,
                class: e.name + "_wrapper"
            }, u))), s && (e.list = a(s.tag, t({
                dest: [s.destination, s.position],
                id: s.id,
                role: "listbox",
                hidden: "hidden"
            }, s.class && {class: s.class}))), T(e), e.data.cache) return d(e).then((function(e) {
                try {
                    return c.call(n)
                } catch (e) {
                    return i(e)
                }
            }), i);

            function c() {
                return f("init", e), r()
            }

            return c.call(n)
        }))
    }

    function x(e) {
        var t = e.prototype;
        t.init = function() {
            E(this)
        }, t.start = function(e) {
            j(this, e)
        }, t.unInit = function() {
            if (this.wrapper) {
                var e = this.wrapper.parentNode;
                e.insertBefore(this.input, this.wrapper), e.removeChild(this.wrapper)
            }
            var t;
            S((t = this).events, (function(e, n) {
                t[e].removeEventListener(n, t.events[e][n])
            }))
        }, t.open = function() {
            g(this)
        }, t.close = function() {
            w(this)
        }, t.goTo = function(e) {
            O(e, this)
        }, t.next = function() {
            A(this)
        }, t.previous = function() {
            k(this)
        }, t.select = function(e) {
            L(this, null, e)
        }, t.search = function(e, t, n) {
            return p(e, t, n)
        }
    }

    return function e(t) {
        this.options = t, this.id = e.instances = (e.instances || 0) + 1, this.name = "autoComplete", this.wrapper = 1, this.threshold = 1, this.debounce = 0, this.resultsList = {
            position: "afterend",
            tag: "ul",
            maxResults: 5
        }, this.resultItem = {tag: "li"}, function(e) {
            var t = e.name, r = e.options, i = e.resultsList, o = e.resultItem;
            for (var s in r) if ("object" === n(r[s])) for (var a in e[s] || (e[s] = {}), r[s]) e[s][a] = r[s][a]; else e[s] = r[s];
            e.selector = e.selector || "#" + t, i.destination = i.destination || e.selector, i.id = i.id || t + "_list_" + e.id, o.id = o.id || t + "_result", e.input = u(e.selector)
        }(this), x.call(this, e), E(this)
    }
},  true ? module.exports = t() : undefined;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRhcmVrcmFhZmF0L2F1dG9jb21wbGV0ZS5qcy9kaXN0L2F1dG9Db21wbGV0ZS5taW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsK0RBQStEO0FBQzNHO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsYUFBYSwyQkFBMkIsU0FBUztBQUM3RSxLQUFLO0FBQ0wsa0RBQWtELGdEQUFnRDtBQUNsRyxLQUFLO0FBQ0wsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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aXMsIHQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIGUoZSwgdCkge1xuICAgICAgICB2YXIgbiA9IE9iamVjdC5rZXlzKGUpO1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgICAgICAgICAgdCAmJiAociA9IHIuZmlsdGVyKChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdCkuZW51bWVyYWJsZVxuICAgICAgICAgICAgfSkpKSwgbi5wdXNoLmFwcGx5KG4sIHIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0KHQpIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IDE7IG4gPCBhcmd1bWVudHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBpID0gbnVsbCAhPSBhcmd1bWVudHNbbl0gPyBhcmd1bWVudHNbbl0gOiB7fTtcbiAgICAgICAgICAgIG4gJSAyID8gZShPYmplY3QoaSksICEwKS5mb3JFYWNoKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgcih0LCBlLCBpW2VdKVxuICAgICAgICAgICAgfSkpIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhpKSkgOiBlKE9iamVjdChpKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksIGUpKVxuICAgICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuKGUpIHtcbiAgICAgICAgcmV0dXJuIG4gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGVcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIGUuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBlICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBlXG4gICAgICAgIH0sIG4oZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByKGUsIHQsIG4pIHtcbiAgICAgICAgcmV0dXJuIHQgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCB0LCB7XG4gICAgICAgICAgICB2YWx1ZTogbixcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9KSA6IGVbdF0gPSBuLCBlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaShlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkgcmV0dXJuIHMoZSlcbiAgICAgICAgfShlKSB8fCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gZVtTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gZVtcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKGUpXG4gICAgICAgIH0oZSkgfHwgbyhlKSB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpXG4gICAgICAgIH0oKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG8oZSwgdCkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHJldHVybiBzKGUsIHQpO1xuICAgICAgICAgICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpO1xuICAgICAgICAgICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IG4gJiYgZS5jb25zdHJ1Y3RvciAmJiAobiA9IGUuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IG4gfHwgXCJTZXRcIiA9PT0gbiA/IEFycmF5LmZyb20oZSkgOiBcIkFyZ3VtZW50c1wiID09PSBuIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pID8gcyhlLCB0KSA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcyhlLCB0KSB7XG4gICAgICAgIChudWxsID09IHQgfHwgdCA+IGUubGVuZ3RoKSAmJiAodCA9IGUubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgbiA9IDAsIHIgPSBuZXcgQXJyYXkodCk7IG4gPCB0OyBuKyspIHJbbl0gPSBlW25dO1xuICAgICAgICByZXR1cm4gclxuICAgIH1cblxuICAgIHZhciB1ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZSkgOiBlKClcbiAgICB9LCBhID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICB2YXIgbiA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpIDogZTtcbiAgICAgICAgZm9yICh2YXIgciBpbiB0KSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRbcl07XG4gICAgICAgICAgICBpZiAoXCJpbnNpZGVcIiA9PT0gcikgaS5hcHBlbmQobik7IGVsc2UgaWYgKFwiZGVzdFwiID09PSByKSB1KGlbMF0pLmluc2VydEFkamFjZW50RWxlbWVudChpWzFdLCBuKTsgZWxzZSBpZiAoXCJhcm91bmRcIiA9PT0gcikge1xuICAgICAgICAgICAgICAgIHZhciBvID0gaTtcbiAgICAgICAgICAgICAgICBvLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG4sIG8pLCBuLmFwcGVuZChvKSwgbnVsbCAhPSBvLmdldEF0dHJpYnV0ZShcImF1dG9mb2N1c1wiKSAmJiBvLmZvY3VzKClcbiAgICAgICAgICAgIH0gZWxzZSByIGluIG4gPyBuW3JdID0gaSA6IG4uc2V0QXR0cmlidXRlKHIsIGkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5cbiAgICB9LCBjID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICByZXR1cm4gZSA9IFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpLCB0ID8gZS5ub3JtYWxpemUoXCJORkRcIikucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIikubm9ybWFsaXplKFwiTkZDXCIpIDogZVxuICAgIH0sIGwgPSBmdW5jdGlvbihlLCBuKSB7XG4gICAgICAgIHJldHVybiBhKFwibWFya1wiLCB0KHtpbm5lckhUTUw6IGV9LCBcInN0cmluZ1wiID09IHR5cGVvZiBuICYmIHtjbGFzczogbn0pKS5vdXRlckhUTUxcbiAgICB9LCBmID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICB0LmlucHV0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGUsIHtidWJibGVzOiAhMCwgZGV0YWlsOiB0LmZlZWRiYWNrLCBjYW5jZWxhYmxlOiAhMH0pKVxuICAgIH0sIHAgPSBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgIHZhciByID0gbiB8fCB7fSwgaSA9IHIubW9kZSwgbyA9IHIuZGlhY3JpdGljcywgcyA9IHIuaGlnaGxpZ2h0LCB1ID0gYyh0LCBvKTtcbiAgICAgICAgaWYgKHQgPSBTdHJpbmcodCksIGUgPSBjKGUsIG8pLCBcImxvb3NlXCIgPT09IGkpIHtcbiAgICAgICAgICAgIHZhciBhID0gKGUgPSBlLnJlcGxhY2UoLyAvZywgXCJcIikpLmxlbmd0aCwgZiA9IDAsIHAgPSBBcnJheS5mcm9tKHQpLm1hcCgoZnVuY3Rpb24odCwgbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmIDwgYSAmJiB1W25dID09PSBlW2ZdICYmICh0ID0gcyA/IGwodCwgcykgOiB0LCBmKyspLCB0XG4gICAgICAgICAgICB9KSkuam9pbihcIlwiKTtcbiAgICAgICAgICAgIGlmIChmID09PSBhKSByZXR1cm4gcFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGQgPSB1LmluZGV4T2YoZSk7XG4gICAgICAgICAgICBpZiAofmQpIHJldHVybiBlID0gdC5zdWJzdHJpbmcoZCwgZCArIGUubGVuZ3RoKSwgZCA9IHMgPyB0LnJlcGxhY2UoZSwgbChlLCBzKSkgOiB0XG4gICAgICAgIH1cbiAgICB9LCBkID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgcmV0dXJuIChpID0gZS5kYXRhKS5jYWNoZSAmJiBpLnN0b3JlID8gbigpIDogbmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsIG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBpLnNyYyA/IGkuc3JjKHQpLnRoZW4oZSwgbikgOiBlKGkuc3JjKVxuICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5mZWVkYmFjayA9IGkuc3RvcmUgPSB0LCBmKFwicmVzcG9uc2VcIiwgZSksIG4oKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIoZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgcilcbiAgICAgICAgfSkpXG4gICAgfSwgaCA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICAgICAgdmFyIG4gPSB0LmRhdGEsIHIgPSB0LnNlYXJjaEVuZ2luZSwgaSA9IFtdO1xuICAgICAgICBuLnN0b3JlLmZvckVhY2goKGZ1bmN0aW9uKHMsIHUpIHtcbiAgICAgICAgICAgIHZhciBhID0gZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgIHZhciBvID0gbiA/IHNbbl0gOiBzLCB1ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiByID8gcihlLCBvKSA6IHAoZSwgbywge1xuICAgICAgICAgICAgICAgICAgICBtb2RlOiByLFxuICAgICAgICAgICAgICAgICAgICBkaWFjcml0aWNzOiB0LmRpYWNyaXRpY3MsXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodDogdC5yZXN1bHRJdGVtLmhpZ2hsaWdodFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0ge21hdGNoOiB1LCB2YWx1ZTogc307XG4gICAgICAgICAgICAgICAgICAgIG4gJiYgKGEua2V5ID0gbiksIGkucHVzaChhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobi5rZXlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMsIGwgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGVbU3ltYm9sLml0ZXJhdG9yXSB8fCBlW1wiQEBpdGVyYXRvclwiXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSB8fCAobiA9IG8oZSkpIHx8IHQgJiYgZSAmJiBcIm51bWJlclwiID09IHR5cGVvZiBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gJiYgKGUgPSBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IDAsIGkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6IGksIG46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgPj0gZS5sZW5ndGggPyB7ZG9uZTogITB9IDoge2RvbmU6ICExLCB2YWx1ZTogZVtyKytdfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGY6IGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcywgdSA9ICEwLCBhID0gITE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbi5jYWxsKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IG4ubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1ID0gZS5kb25lLCBlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9ICEwLCBzID0gZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSB8fCBudWxsID09IG4ucmV0dXJuIHx8IG4ucmV0dXJuKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSkgdGhyb3cgc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0obi5rZXlzKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGwucygpOyAhKGMgPSBsLm4oKSkuZG9uZTspIGEoYy52YWx1ZSlcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGwuZShlKVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGwuZigpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGEoKVxuICAgICAgICB9KSksIG4uZmlsdGVyICYmIChpID0gbi5maWx0ZXIoaSkpO1xuICAgICAgICB2YXIgcyA9IGkuc2xpY2UoMCwgdC5yZXN1bHRzTGlzdC5tYXhSZXN1bHRzKTtcbiAgICAgICAgdC5mZWVkYmFjayA9IHtxdWVyeTogZSwgbWF0Y2hlczogaSwgcmVzdWx0czogc30sIGYoXCJyZXN1bHRzXCIsIHQpXG4gICAgfSwgbSA9IFwiYXJpYS1leHBhbmRlZFwiLCBiID0gXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgeSA9IFwiYXJpYS1zZWxlY3RlZFwiLCB2ID0gZnVuY3Rpb24oZSwgbikge1xuICAgICAgICBlLmZlZWRiYWNrLnNlbGVjdGlvbiA9IHQoe2luZGV4OiBufSwgZS5mZWVkYmFjay5yZXN1bHRzW25dKVxuICAgIH0sIGcgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICBlLmlzT3BlbiB8fCAoKGUud3JhcHBlciB8fCBlLmlucHV0KS5zZXRBdHRyaWJ1dGUobSwgITApLCBlLmxpc3QucmVtb3ZlQXR0cmlidXRlKFwiaGlkZGVuXCIpLCBlLmlzT3BlbiA9ICEwLCBmKFwib3BlblwiLCBlKSlcbiAgICB9LCB3ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLmlzT3BlbiAmJiAoKGUud3JhcHBlciB8fCBlLmlucHV0KS5zZXRBdHRyaWJ1dGUobSwgITEpLCBlLmlucHV0LnNldEF0dHJpYnV0ZShiLCBcIlwiKSwgZS5saXN0LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCBcIlwiKSwgZS5pc09wZW4gPSAhMSwgZihcImNsb3NlXCIsIGUpKVxuICAgIH0sIE8gPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgIHZhciBuID0gdC5yZXN1bHRJdGVtLCByID0gdC5saXN0LmdldEVsZW1lbnRzQnlUYWdOYW1lKG4udGFnKSwgbyA9ICEhbi5zZWxlY3RlZCAmJiBuLnNlbGVjdGVkLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgaWYgKHQuaXNPcGVuICYmIHIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcywgdSwgYSA9IHQuY3Vyc29yO1xuICAgICAgICAgICAgZSA+PSByLmxlbmd0aCAmJiAoZSA9IDApLCBlIDwgMCAmJiAoZSA9IHIubGVuZ3RoIC0gMSksIHQuY3Vyc29yID0gZSwgYSA+IC0xICYmIChyW2FdLnJlbW92ZUF0dHJpYnV0ZSh5KSwgbyAmJiAodSA9IHJbYV0uY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkodSwgaShvKSkpLCByW2VdLnNldEF0dHJpYnV0ZSh5LCAhMCksIG8gJiYgKHMgPSByW2VdLmNsYXNzTGlzdCkuYWRkLmFwcGx5KHMsIGkobykpLCB0LmlucHV0LnNldEF0dHJpYnV0ZShiLCByW3QuY3Vyc29yXS5pZCksIHQubGlzdC5zY3JvbGxUb3AgPSByW2VdLm9mZnNldFRvcCAtIHQubGlzdC5jbGllbnRIZWlnaHQgKyByW2VdLmNsaWVudEhlaWdodCArIDUsIHQuZmVlZGJhY2suY3Vyc29yID0gdC5jdXJzb3IsIHYodCwgZSksIGYoXCJuYXZpZ2F0ZVwiLCB0KVxuICAgICAgICB9XG4gICAgfSwgQSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgTyhlLmN1cnNvciArIDEsIGUpXG4gICAgfSwgayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgTyhlLmN1cnNvciAtIDEsIGUpXG4gICAgfSwgTCA9IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgICAgICAgKG4gPSBuID49IDAgPyBuIDogZS5jdXJzb3IpIDwgMCB8fCAoZS5mZWVkYmFjay5ldmVudCA9IHQsIHYoZSwgbiksIGYoXCJzZWxlY3Rpb25cIiwgZSksIHcoZSkpXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGooZSwgbikge1xuICAgICAgICB2YXIgciA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oaSwgbykge1xuICAgICAgICAgICAgdmFyIHMsIHU7XG4gICAgICAgICAgICByZXR1cm4gcyA9IG4gfHwgKCh1ID0gZS5pbnB1dCkgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8IHUgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50ID8gdS52YWx1ZSA6IHUuaW5uZXJIVE1MKSwgZnVuY3Rpb24oZSwgdCwgbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ID8gdChlKSA6IGUubGVuZ3RoID49IG5cbiAgICAgICAgICAgIH0ocyA9IGUucXVlcnkgPyBlLnF1ZXJ5KHMpIDogcywgZS50cmlnZ2VyLCBlLnRocmVzaG9sZCkgPyBkKGUsIHMpLnRoZW4oKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5mZWVkYmFjayBpbnN0YW5jZW9mIEVycm9yID8gaSgpIDogKGgocywgZSksIGUucmVzdWx0c0xpc3QgJiYgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlLnJlc3VsdHNMaXN0LCByID0gZS5saXN0LCBpID0gZS5yZXN1bHRJdGVtLCBvID0gZS5mZWVkYmFjaywgcyA9IG8ubWF0Y2hlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gby5yZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY3Vyc29yID0gLTEsIHIuaW5uZXJIVE1MID0gXCJcIiwgcy5sZW5ndGggfHwgbi5ub1Jlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBEb2N1bWVudEZyYWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUuZm9yRWFjaCgoZnVuY3Rpb24oZSwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGEoaS50YWcsIHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwiXCIuY29uY2F0KGkuaWQsIFwiX1wiKS5jb25jYXQobiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcIm9wdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MOiBlLm1hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlOiBjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGkuY2xhc3MgJiYge2NsYXNzOiBpLmNsYXNzfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLmVsZW1lbnQgJiYgaS5lbGVtZW50KHIsIGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCByLmFwcGVuZChjKSwgbi5lbGVtZW50ICYmIG4uZWxlbWVudChyLCBvKSwgZyhlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHcoZSlcbiAgICAgICAgICAgICAgICAgICAgfShlKSwgYy5jYWxsKHIpKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8oZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgbykgOiAodyhlKSwgYy5jYWxsKHIpKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gYygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKVxuICAgIH1cblxuICAgIHZhciBTID0gZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICBmb3IgKHZhciBuIGluIGUpIGZvciAodmFyIHIgaW4gZVtuXSkgdChuLCByKVxuICAgIH0sIFQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBuLCByLCBpLCBvID0gZS5ldmVudHMsIHMgPSAobiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGooZSlcbiAgICAgICAgfSwgciA9IGUuZGVib3VuY2UsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGkpLCBpID0gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG4oKVxuICAgICAgICAgICAgfSksIHIpXG4gICAgICAgIH0pLCB1ID0gZS5ldmVudHMgPSB0KHtpbnB1dDogdCh7fSwgbyAmJiBvLmlucHV0KX0sIGUucmVzdWx0c0xpc3QgJiYge2xpc3Q6IG8gPyB0KHt9LCBvLmxpc3QpIDoge319KSwgYSA9IHtcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzKClcbiAgICAgICAgICAgICAgICB9LCBrZXlkb3duOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCA0MCA9PT0gZS5rZXlDb2RlID8gQSh0KSA6IGsodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuc3VibWl0IHx8IGUucHJldmVudERlZmF1bHQoKSwgdC5jdXJzb3IgPj0gMCAmJiBMKHQsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQucmVzdWx0c0xpc3QudGFiU2VsZWN0ICYmIHQuY3Vyc29yID49IDAgJiYgTCh0LCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5pbnB1dC52YWx1ZSA9IFwiXCIsIHcodClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSh0LCBlKVxuICAgICAgICAgICAgICAgIH0sIGJsdXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB3KGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbGlzdDoge1xuICAgICAgICAgICAgICAgIG1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICB9LCBjbGljazogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSB0LnJlc3VsdEl0ZW0udGFnLnRvVXBwZXJDYXNlKCksIHIgPSBBcnJheS5mcm9tKHQubGlzdC5xdWVyeVNlbGVjdG9yQWxsKG4pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gZS50YXJnZXQuY2xvc2VzdChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgJiYgaS5ub2RlTmFtZSA9PT0gbiAmJiBMKHQsIGUsIHIuaW5kZXhPZihpKSlcbiAgICAgICAgICAgICAgICAgICAgfSh0LCBlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUyhhLCAoZnVuY3Rpb24odCwgbikge1xuICAgICAgICAgICAgKGUucmVzdWx0c0xpc3QgfHwgXCJpbnB1dFwiID09PSBuKSAmJiAodVt0XVtuXSB8fCAodVt0XVtuXSA9IGFbdF1bbl0pKVxuICAgICAgICB9KSksIFModSwgKGZ1bmN0aW9uKHQsIG4pIHtcbiAgICAgICAgICAgIGVbdF0uYWRkRXZlbnRMaXN0ZW5lcihuLCB1W3RdW25dKVxuICAgICAgICB9KSlcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRShlKSB7XG4gICAgICAgIHZhciBuID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihyLCBpKSB7XG4gICAgICAgICAgICB2YXIgbywgcywgdTtcbiAgICAgICAgICAgIGlmIChvID0gZS5wbGFjZUhvbGRlciwgdSA9IHtcbiAgICAgICAgICAgICAgICByb2xlOiBcImNvbWJvYm94XCIsXG4gICAgICAgICAgICAgICAgXCJhcmlhLW93bnNcIjogKHMgPSBlLnJlc3VsdHNMaXN0KS5pZCxcbiAgICAgICAgICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogITAsXG4gICAgICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6ICExXG4gICAgICAgICAgICB9LCBhKGUuaW5wdXQsIHQodCh7XG4gICAgICAgICAgICAgICAgXCJhcmlhLWNvbnRyb2xzXCI6IHMuaWQsXG4gICAgICAgICAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImJvdGhcIlxuICAgICAgICAgICAgfSwgbyAmJiB7cGxhY2Vob2xkZXI6IG99KSwgIWUud3JhcHBlciAmJiB0KHt9LCB1KSkpLCBlLndyYXBwZXIgJiYgKGUud3JhcHBlciA9IGEoXCJkaXZcIiwgdCh7XG4gICAgICAgICAgICAgICAgYXJvdW5kOiBlLmlucHV0LFxuICAgICAgICAgICAgICAgIGNsYXNzOiBlLm5hbWUgKyBcIl93cmFwcGVyXCJcbiAgICAgICAgICAgIH0sIHUpKSksIHMgJiYgKGUubGlzdCA9IGEocy50YWcsIHQoe1xuICAgICAgICAgICAgICAgIGRlc3Q6IFtzLmRlc3RpbmF0aW9uLCBzLnBvc2l0aW9uXSxcbiAgICAgICAgICAgICAgICBpZDogcy5pZCxcbiAgICAgICAgICAgICAgICByb2xlOiBcImxpc3Rib3hcIixcbiAgICAgICAgICAgICAgICBoaWRkZW46IFwiaGlkZGVuXCJcbiAgICAgICAgICAgIH0sIHMuY2xhc3MgJiYge2NsYXNzOiBzLmNsYXNzfSkpKSwgVChlKSwgZS5kYXRhLmNhY2hlKSByZXR1cm4gZChlKS50aGVuKChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuY2FsbChuKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkoZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgaSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoXCJpbml0XCIsIGUpLCByKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGMuY2FsbChuKVxuICAgICAgICB9KSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB4KGUpIHtcbiAgICAgICAgdmFyIHQgPSBlLnByb3RvdHlwZTtcbiAgICAgICAgdC5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBFKHRoaXMpXG4gICAgICAgIH0sIHQuc3RhcnQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBqKHRoaXMsIGUpXG4gICAgICAgIH0sIHQudW5Jbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLndyYXBwZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBlLmluc2VydEJlZm9yZSh0aGlzLmlucHV0LCB0aGlzLndyYXBwZXIpLCBlLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgUygodCA9IHRoaXMpLmV2ZW50cywgKGZ1bmN0aW9uKGUsIG4pIHtcbiAgICAgICAgICAgICAgICB0W2VdLnJlbW92ZUV2ZW50TGlzdGVuZXIobiwgdC5ldmVudHNbZV1bbl0pXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfSwgdC5vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBnKHRoaXMpXG4gICAgICAgIH0sIHQuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHcodGhpcylcbiAgICAgICAgfSwgdC5nb1RvID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgTyhlLCB0aGlzKVxuICAgICAgICB9LCB0Lm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEEodGhpcylcbiAgICAgICAgfSwgdC5wcmV2aW91cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgayh0aGlzKVxuICAgICAgICB9LCB0LnNlbGVjdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIEwodGhpcywgbnVsbCwgZSlcbiAgICAgICAgfSwgdC5zZWFyY2ggPSBmdW5jdGlvbihlLCB0LCBuKSB7XG4gICAgICAgICAgICByZXR1cm4gcChlLCB0LCBuKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGUodCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0LCB0aGlzLmlkID0gZS5pbnN0YW5jZXMgPSAoZS5pbnN0YW5jZXMgfHwgMCkgKyAxLCB0aGlzLm5hbWUgPSBcImF1dG9Db21wbGV0ZVwiLCB0aGlzLndyYXBwZXIgPSAxLCB0aGlzLnRocmVzaG9sZCA9IDEsIHRoaXMuZGVib3VuY2UgPSAwLCB0aGlzLnJlc3VsdHNMaXN0ID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWZ0ZXJlbmRcIixcbiAgICAgICAgICAgIHRhZzogXCJ1bFwiLFxuICAgICAgICAgICAgbWF4UmVzdWx0czogNVxuICAgICAgICB9LCB0aGlzLnJlc3VsdEl0ZW0gPSB7dGFnOiBcImxpXCJ9LCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGUubmFtZSwgciA9IGUub3B0aW9ucywgaSA9IGUucmVzdWx0c0xpc3QsIG8gPSBlLnJlc3VsdEl0ZW07XG4gICAgICAgICAgICBmb3IgKHZhciBzIGluIHIpIGlmIChcIm9iamVjdFwiID09PSBuKHJbc10pKSBmb3IgKHZhciBhIGluIGVbc10gfHwgKGVbc10gPSB7fSksIHJbc10pIGVbc11bYV0gPSByW3NdW2FdOyBlbHNlIGVbc10gPSByW3NdO1xuICAgICAgICAgICAgZS5zZWxlY3RvciA9IGUuc2VsZWN0b3IgfHwgXCIjXCIgKyB0LCBpLmRlc3RpbmF0aW9uID0gaS5kZXN0aW5hdGlvbiB8fCBlLnNlbGVjdG9yLCBpLmlkID0gaS5pZCB8fCB0ICsgXCJfbGlzdF9cIiArIGUuaWQsIG8uaWQgPSBvLmlkIHx8IHQgKyBcIl9yZXN1bHRcIiwgZS5pbnB1dCA9IHUoZS5zZWxlY3RvcilcbiAgICAgICAgfSh0aGlzKSwgeC5jYWxsKHRoaXMsIGUpLCBFKHRoaXMpXG4gICAgfVxufSwgXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBtb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA9IHQoKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUodCkgOiAoZSA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzIDogZSB8fCBzZWxmKS5hdXRvQ29tcGxldGUgPSB0KCk7XG4iXSwic291cmNlUm9vdCI6IiJ9